import org.apache.tools.ant.filters.ReplaceTokens

plugins {
	id 'java'
	id 'maven-publish'
	id 'checkstyle'
	id "com.github.node-gradle.node" version "7.0.1"
	id 'com.github.gmazzo.buildconfig' version '3.0.3'
	id "org.sonarqube" version "4.4.1.3373"
	id "org.owasp.dependencycheck" version "12.1.9"
	id 'biz.aQute.bnd.builder' version '6.4.0'
}

allprojects {
	apply plugin: 'com.github.node-gradle.node'
}

dependencyCheck {
	nvd {
		apiKey=System.getenv("NVD_API_KEY") ?: ""
		delay=30000
	}
	formats = ['ALL']
    analyzers {
        nodeAudit {
            skipDevDependencies = true
        }
        nodePackage {
			skipDevDependencies = true
		}
    }
}

def zkcmlDir = "$rootDir/../zkcml"
def resources = 'src/main/resources'
def codegen = 'codegen/resources'
ext {
	zkprojects = [
			'zk'           : "$rootDir/zk",
			'zkplus'       : "$rootDir/zkplus",
			'zweb-dsp'     : "$rootDir/zweb-dsp",
			'zhtml'        : "$rootDir/zhtml",
			'zweb'         : "$rootDir/zweb",
			'zel'          : "$rootDir/zel",
			'zkbind'       : "$rootDir/zkbind",
			'zcommon'      : "$rootDir/zcommon",
			'zkwebfragment': "$rootDir/zkwebfragment",
			'zul'          : "$rootDir/zul",
			'za11y'        : "$zkcmlDir/za11y",
			'zkex'         : "$zkcmlDir/zkex",
			'zkmax'        : "$zkcmlDir/zkmax",
			'zml'          : "$zkcmlDir/zml",
			'zuti'         : "$zkcmlDir/zuti",
			'stateless'       : "$zkcmlDir/stateless",
			'stateless-immutable': "$zkcmlDir/stateless-immutable",
			'client-bind' : "$zkcmlDir/client-bind"
	]
	zkcmlprojects = [
			'za11y': "$zkcmlDir/za11y",
			'zkex' : "$zkcmlDir/zkex",
			'zkmax': "$zkcmlDir/zkmax",
			'zml'  : "$zkcmlDir/zml",
			'zuti' : "$zkcmlDir/zuti",
			'stateless' : "$zkcmlDir/stateless",
			'stateless-immutable': "$zkcmlDir/stateless-immutable",
			'client-bind' : "$zkcmlDir/client-bind"
	]
}

apply {
	from 'release.gradle'
	from 'javadoc.gradle'
}

// add repositories here for checkstyle plugin
repositories {
	mavenCentral()
}

task buildESLintPlugin(type: NpmTask) {
	dependsOn npm_install
	args = ['run', 'build', '-w', "eslint-plugin-zk"]
}

if (project.ext['gradleFrontendSkip'] == 'false') {
	clean {
		dependsOn buildESLintPlugin
	}
	classes.dependsOn buildESLintPlugin
}

subprojects {
	// Apply bnd plugin for OSGi manifest generation
	apply plugin: 'biz.aQute.bnd.builder'

	// Repositories for all subprojects (from 9.6.0 zk-parent)
	repositories {
		mavenCentral()

		maven {
			name = 'ZK Repository'
			url = uri('https://mavensync.zkoss.org/maven2')
		}
	}

	sonarqube {
		properties {
			if (new File("$projectDir/$resources/web").exists()) {
				property 'sonar.sources', "$projectDir/src/main/java, $projectDir/$resources/web"
				property 'sonar.sources.exclusions', '**/package.html'
			} else if (new File("$projectDir/src/main/java").exists()) {
				property 'sonar.sources', "$projectDir/src/main/java"
				property 'sonar.sources.exclusions', '**/package.html'
			}
		}
	}

	// Prepare the result of TypeScript before gradle assemble
	task compileTypeScript() {
		setOnlyIf { project.ext['gradleFrontendSkip'] == 'false' }
		if (new File("$projectDir/$resources/web/js").exists()) {
			inputs.dir("$projectDir/$resources/web/js")
			outputs.dir("$projectDir/$codegen/web/js")

			doLast {
				exec {
					if (project.hasProperty("devMode")) {
						commandLine "$rootDir/node_modules/.bin/gulp", 'build:single', "--src=$projectDir/$resources/web/js", "--dest=$projectDir/$codegen/web/js", "--devMode=true"
					} else {
						commandLine "$rootDir/node_modules/.bin/gulp", 'build:single', "--src=$projectDir/$resources/web/js", "--dest=$projectDir/$codegen/web/js"
					}
				}
			}
		}
	}

	task compileCSS() {
		setOnlyIf { project.ext['gradleFrontendSkip'] == 'false' }

		if (new File("$projectDir/$resources/web/$project.name/css").exists()) {
			inputs.dir("$projectDir/$resources/web/$project.name/css")
			outputs.dir("$projectDir/$codegen/web/$project.name/css")

			doLast {
				exec {
					commandLine "$rootDir/node_modules/.bin/gulp", 'build:minify-css', "--src=$projectDir/$resources/web/$project.name/css", "--dest=$projectDir/$codegen/web/$project.name/css"
				}
			}
		}
	}

	java.sourceCompatibility = JavaVersion.VERSION_11
	tasks.withType(JavaCompile) {
		options.encoding = 'UTF-8'
		options.warnings = false
	}

	checkstyle {
		toolVersion '10.18.1'
	}

	// eslint
	task jscheck(type: NpmTask) {
		dependsOn rootProject.tasks.named('npm_install')
		setOnlyIf { project.ext['gradleFrontendSkip'] == 'false' }
		workingDir = rootDir
		def eslintDir = project.file(".eslintrc.js").exists() ? projectDir : rootDir;
		args =['run', 'lint', '--', "$projectDir/$resources/web/js", "--config=$eslintDir/.eslintrc.js", "--ignore-path=$rootDir/.eslintignore"]
	}

	// NOTE: Do not depend on this task for normal build.
	// This task is to make applying eslint auto-fixes easier, and is meant to be
	// called manually: `./gradlew jsfix`.
	task jsfix(type: NpmTask) {
		workingDir = rootDir
		def eslintDir = project.file(".eslintrc.js").exists() ? projectDir : rootDir;
		args =['run', 'lint', '--', "$projectDir/$resources/web/js", "--config=$eslintDir/.eslintrc.js", "--ignore-path=$rootDir/.eslintignore", "--fix"]
	}

	check {
		dependsOn(jscheck)
	}

	// Compile LESS
	task compileLess() {
		setOnlyIf { project.ext['gradleFrontendSkip'] == 'false' }
		if (new File("$projectDir/$resources/web/$project.name/").exists()) {
			inputs.dir("$projectDir/$resources/web/$project.name/")
			outputs.dir("$projectDir/$codegen/web/$project.name/")
			doLast {
				exec {
					commandLine "$rootDir/node_modules/.bin/zklessc", '-s', "$projectDir/$resources/web/", '-o', "$projectDir/$codegen/web/", '-i', "$rootDir/zul/$resources/web/", '-i', "$zkcmlDir/zkmax/$resources/web/", '-c'
				}
			}
		}
	}

	task codegenMessages() {
		if (new File("$projectDir/$resources/metainfo/mesg").exists()) {
			doFirst {
				exec {
					commandLine 'bash', "$rootDir/bin/genprop", '-x', "$projectDir/$resources/metainfo/mesg/", "$projectDir/src/main/java"
				}
			}
		}
	}
	compileJava {
		dependsOn(codegenMessages)
	}

	// Configure additional resource for generated resources
	processResources() {
		dependsOn(compileJava)
		dependsOn(compileTypeScript)
		dependsOn(compileLess)
		dependsOn(compileCSS)

		from("$projectDir/$codegen") {
			setDuplicatesStrategy(DuplicatesStrategy.INCLUDE)
		}

		// replace @version@ token in xml files
		from('src/main/resources') {
			include "**/config.xml", "**/lang.xml", "**/lang-addon.xml"
			filter(ReplaceTokens, tokens: [version: "$version".toString()])
			// Gstring to String
			setDuplicatesStrategy(DuplicatesStrategy.INCLUDE)
		}
	}

	jar {
		bundle {
			// Read standard headers from MANIFEST.MF
			def manifestFile = file("$projectDir/$resources/META-INF/MANIFEST.MF")
			def bndInstructions = """
				# OSGi Bundle headers
				Bundle-ManifestVersion: 2
				Bundle-Name: ${project.name}
				Bundle-SymbolicName: ${project.name}
				Bundle-Version: ${version}

				# Use -exportcontents instead of Export-Package
				# This exports packages WITHOUT embedding dependency classes
				-exportcontents: *;version=${version}

			# Only include classes from this project's output
			-sources: false

			# Import all packages as optional
			Import-Package: *;resolution:=optional

				# Don't include dependency classes
				-noclassforname: true

				# Don't add extra bnd headers
				-noextraheaders: true

				# Don't fail on missing packages
				-failok: true
			"""

			// Special handling for different projects
			if ("${project.name}" == 'zweb') {
				bndInstructions += """
					Import-Package: javax.servlet.annotation;resolution:=optional,*;resolution:=optional
				"""
			} else if ("${project.name}" == 'zkbind') {
				bndInstructions += """
					Import-Package: javassist.util.proxy;resolution:=optional,*;resolution:=optional
				"""
			} else if ("${project.name}" == 'zkex') {
				bndInstructions += """
					Import-Package: org.zkoss.zk.ui.sys;resolution:=optional,*;resolution:=optional
					-exportcontents: !org.zkoss.zk.ui.sys,*;version=${version}
				"""
			} else if ("${project.name}" == 'zweb-dsp') {
				def fragmentHostVersion = "${version}".split(/[\\.-][a-zA-Z]/)[0]
				bndInstructions += """
					Fragment-Host: zweb;bundle-version=${fragmentHostVersion}
				"""
			}

			// Read standard headers from MANIFEST.MF and add to bnd instructions
			if (manifestFile.exists()) {
				manifestFile.withInputStream { is ->
					def existingManifest = new java.util.jar.Manifest(is)
					existingManifest.mainAttributes.each { key, value ->
						def keyStr = key.toString()
						// Add non-OSGi headers to bnd instructions
						if (!keyStr.startsWith('Bundle-') &&
						    !keyStr.startsWith('Export-') &&
						    !keyStr.startsWith('Import-') &&
						    keyStr != 'Manifest-Version') {
							bndInstructions += """
								${keyStr}: ${value}
							"""
						}
					}
				}
			}

			// Add version headers
			bndInstructions += """
				Specification-Version: ${version}
				Implementation-Version: ${version}
			"""

			bnd bndInstructions
		}
	}

	// build sources jar each subproject for bundle
	task sourcesJar(type: Jar) {
		dependsOn(generateBuildConfig)
		archiveClassifier = 'sources'

		// add generated java in to source
		from "$buildDir/generated/source/buildConfig/main/main"

		from 'src/main/java'
		exclude "**/package.html"
		setDuplicatesStrategy(DuplicatesStrategy.INCLUDE)

		manifest {
			def osgiHeaders = [
				// OSGi Headers
				"Bundle-ManifestVersion": "2",
				"Bundle-Name": project.name,
				"Bundle-SymbolicName": project.name,
				"Bundle-Version": version,
				"Import-Package": "*;resolution:=optional",
				"Specification-Version": version,
				"Implementation-Version": version
			]

			// Generate Export-Package by scanning source files
			def exportPackages = [] as Set

			// Scan Java source files
			def srcDir = file("$projectDir/src/main/java")
			if (srcDir.exists()) {
				fileTree(srcDir).matching {
					include '**/*.java'
				}.each { javaFile ->
					def relativePath = srcDir.toPath().relativize(javaFile.toPath()).toString()
					def packagePath = relativePath.substring(0, relativePath.lastIndexOf('/'))
					def packageName = packagePath.replace('/', '.')
					if (packageName && !packageName.isEmpty()) {
						exportPackages.add(packageName)
					}
				}
			}

			// Scan resources for additional packages
			def resourcesDir = file("$projectDir/$resources")
			if (resourcesDir.exists()) {
				fileTree(resourcesDir).matching {
					include '**/*'
					exclude '**/*.MF', '**/*.SF', '**/*.DSA', '**/*.RSA'
				}.each { resourceFile ->
					if (resourceFile.isFile()) {
						def relativePath = resourcesDir.toPath().relativize(resourceFile.toPath()).toString()
						if (relativePath.contains('/')) {
							def packagePath = relativePath.substring(0, relativePath.lastIndexOf('/'))
							def packageName = packagePath.replace('/', '.')
							if (packageName && !packageName.isEmpty() && !packageName.startsWith('META-INF')) {
								exportPackages.add(packageName)
							}
						}
					}
				}
			}

			// Build Export-Package string
			if (!exportPackages.isEmpty()) {
				def sortedPackages = exportPackages.sort()
				def exportPackageValue = sortedPackages.collect { "${it};version=\"${version}\"" }.join(',')
				osgiHeaders."Export-Package" = exportPackageValue
			}

			// Special handling for different projects
			if ("${project.name}" == 'zweb') {
				osgiHeaders."Import-Package" = "javax.servlet.annotation;resolution:=optional,*;resolution:=optional"
			} else if ("${project.name}" == 'zkbind') {
				osgiHeaders."Import-Package" = "javassist.util.proxy;resolution:=optional,*;resolution:=optional"
			} else if ("${project.name}" == 'zkex') {
				osgiHeaders."Import-Package" = "org.zkoss.zk.ui.sys;resolution:=optional,*;resolution:=optional"
				// For zkex, exclude org.zkoss.zk.ui.sys from exports
				if (osgiHeaders."Export-Package") {
					osgiHeaders."Export-Package" = "!org.zkoss.zk.ui.sys," + osgiHeaders."Export-Package"
				}
			} else if ("${project.name}" == 'zweb-dsp') {
				def fragmentHostVersion = "${version}".split(/[\\.-][a-zA-Z]/)[0]
				osgiHeaders."Fragment-Host" = "zweb;bundle-version=\"${fragmentHostVersion}\""
			}

			// Read and merge existing MANIFEST.MF attributes (if exists)
			def manifestFile = file("$projectDir/$resources/META-INF/MANIFEST.MF")
			if (manifestFile.exists()) {
				manifestFile.withInputStream { is ->
					def existingManifest = new java.util.jar.Manifest(is)
					existingManifest.mainAttributes.each { key, value ->
						def keyStr = key.toString()
						// Only add if not already defined in osgiHeaders
						if (!osgiHeaders.containsKey(keyStr) && keyStr != 'Manifest-Version') {
							osgiHeaders[keyStr] = value.toString()
						}
					}
				}
			}

			attributes(osgiHeaders)
		}
	}

	// build javadoc jar each subproject for bundle
	task javadocJar(type: Jar) {
		dependsOn 'buildJavadoc'
		setOnlyIf { project.name != 'zkwebfragment' && project.name != 'zweb-dsp' }
		archiveClassifier = 'javadoc'
		from "$javadoc.destinationDir"
	}



	// Delete codegen folder before clean
	clean.doFirst {
		delete "$projectDir/codegen/"
	}

	compileJava.mustRunAfter(rootProject.tasks.named('npm_install'))
	compileTypeScript.mustRunAfter(rootProject.tasks.named('npm_install'))
	compileLess.mustRunAfter(rootProject.tasks.named('npm_install'))
	compileCSS.mustRunAfter(rootProject.tasks.named('npm_install'))
}

task tscheck(type: NpmTask, dependsOn: 'npm_install') {
	setOnlyIf { project.ext['gradleFrontendSkip'] == 'false' }
	args =['run', 'type-check']
}
if (!project.hasProperty("cleanZKOnly") && gradle.includedBuilds.find {it.name == 'zkcml'} != null) {
	def zkcmlBuildTask = gradle.includedBuild('zkcml').task(':build')
	tscheck.dependsOn(gradle.includedBuild('zkcml').task(':tscheck'))
	tscheck.dependsOn(zkcmlBuildTask)
	tscheck.mustRunAfter(zkcmlBuildTask)
} else {
	check.dependsOn(tscheck)
}

// Version Check
def fileCheck(file, regex) {
	println "version check: ${file.path}"
	int matchFound = 0
	file.eachLine { line ->
		if (line ==~ regex)
			matchFound++
	}
	if (matchFound == 0)
		throw new ResourceException("version check faild with: ${file.path}")
}

// check version: gradle versionCheck -Pcheck.version={VERSION}
task versionCheck() {
	if (project.hasProperty("check.version")) {
		fileTree("../").matching {
			include "**/gradle.properties"
		}.each {
			fileCheck(it, /version=${project.getProperty("check.version")}/)
		}
	}
}

task cleanJsdoc(type: Delete) {
	dependsOn(clean)
	delete "$projectDir/jsdoc/codegen/"
}

clean {
	// also clean cml
	if (!project.hasProperty("cleanZKOnly") && gradle.includedBuilds.find {it.name == 'zkcml'} != null) {
		dependsOn(gradle.includedBuild('zkcml').task(':clean'))
		zkcmlprojects.each { prjName, dir ->
			dependsOn(gradle.includedBuild('zkcml').task(":$prjName:clean"))
		}
		// also clean sandbox
		dependsOn(gradle.includedBuild('zksandbox').task(':clean'))
	}
}

build {
	// also build cml
	if (!project.hasProperty("buildZKOnly") && gradle.includedBuilds.find { it.name == 'zkcml' } != null) {
		def zkcmlBuild = gradle.includedBuild('zkcml').task(':build')
		dependsOn(zkcmlBuild)
		zkcmlprojects.each { prjName, dir ->
			dependsOn(gradle.includedBuild('zkcml').task(":$prjName:build"))
		}
	}
}
// change all the version in gradle.properties under zk
// e.g. ./gradlew upVer -PchangeVersionTo=10.0.1-SNAPSHOT
task upVer() {
	doLast {
		if (project.hasProperty("changeVersionTo")) {
			fileTree("$rootDir/").matching {
				include "**/gradle.properties"
			}.each { file ->
				println "upVer: ${file.path} from ${project.version} to ${project.changeVersionTo}"
				ant.replaceregexp(
						file: file,
						match: "version=$project.version",
						replace: "version=$project.changeVersionTo",
				)
			}
			// Update version in pom.xml files in zk-bom and zk-parent
			['zk-bom', 'zk-parent'].each { dir ->
				fileTree("$rootDir/$dir").matching {
					include "pom.xml"
				}.each { file ->
					println "upVer: ${file.path} from ${project.version} to ${project.changeVersionTo}"
					ant.replaceregexp(
							file: file,
							match: "<version>${project.version}</version>",
							replace: "<version>${project.changeVersionTo}</version>",
					)
				}
			}
		}
	}
}